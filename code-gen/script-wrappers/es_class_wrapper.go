package wrappers

type TypeCustomization []string

type ESMethodArgument struct {
	required     bool
	hasDefault   bool
	defaultValue string
	ignored      bool
	encoder      string
	decoder      string
}

func (a *ESMethodArgument) Required()   { a.required = true }
func (a *ESMethodArgument) HasDefault() { a.hasDefault = true }

func (a *ESMethodArgument) HasDefaultValue(value string) {
	a.hasDefault = true
	a.defaultValue = value
}

func (a *ESMethodArgument) Ignore() {
	a.ignored = true
}

func (a *ESMethodArgument) SetEncoder(e string) *ESMethodArgument {
	a.encoder = e
	return a
}
func (a *ESMethodArgument) SetDecoder(d string) *ESMethodArgument {
	a.decoder = d
	return a
}

// ESClassWrapper contains information about how to generate ES wrapper code
// around a class in the web specification.
//
// All classes will be generated using a set of defaults. Data in this structure
// will allow deviating from the defaults.
type ESClassWrapper struct {
	DomSpec                   *WrapperGeneratorFileSpec
	TypeName                  string
	InnerTypeName             string
	WrapperTypeName           string
	Receiver                  string
	RunCustomCode             bool
	WrapperStruct             bool
	SkipPrototypeRegistration bool
	IncludeIncludes           bool
	Customization             map[string]*ESMethodWrapper
}

func (w *ESClassWrapper) ensureMap() {
	if w.Customization == nil {
		w.Customization = make(map[string]*ESMethodWrapper)
	}
}

func (w *ESClassWrapper) MarkMembersAsNotImplemented(names ...string) {
	w.ensureMap()
	for _, name := range names {
		w.Customization[name] = &ESMethodWrapper{NotImplemented: true}
	}
}
func (w *ESClassWrapper) MarkMembersAsIgnored(names ...string) {
	w.ensureMap()
	for _, name := range names {
		w.Customization[name] = &ESMethodWrapper{Ignored: true}
	}
}

func (w *ESClassWrapper) GetMethodCustomization(name string) (result ESMethodWrapper) {
	if val, ok := w.Customization[name]; ok {
		result = *val
	}
	return
}

func (w *ESClassWrapper) Method(name string) (result *ESMethodWrapper) {
	w.ensureMap()
	var ok bool
	if result, ok = w.Customization[name]; !ok {
		result = new(ESMethodWrapper)
		w.Customization[name] = result
	}
	return result
}

// ESMethodWrapper contains information about how to generate ES wrapper code
// around a single class method.
type ESMethodWrapper struct {
	// When set, the ES wrapper will generate an error with the message, "Not implemented"
	NotImplemented bool
	// When set, nothing will be generated for the member
	Ignored bool
	// HasNoError tells that the wrapped Go method doesn't generate an error.
	HasNoError bool
	// CustomImplementation tells that the wrapper code will be generated by hand.
	// Code generator will still install a function on the prototype template
	// referencing the custom function
	CustomImplementation bool
	Arguments            map[string]*ESMethodArgument
	// Name of the method that will convert the result to JS
	Encoder string
}

func (w *ESMethodWrapper) SetEncoder(e string) *ESMethodWrapper {
	w.Encoder = e
	return w
}

// SetNotImplemented is a simple wrapper around [NotImplemented] to support a
// chaning DSL syntax.
func (w *ESMethodWrapper) SetNotImplemented() *ESMethodWrapper {
	w.NotImplemented = true
	return w
}

func (w *ESMethodWrapper) Ignore() *ESMethodWrapper {
	w.Ignored = true
	return w
}

// SetNoError is a simple wrapper around [HasNoError] to support a
// chaning DSL syntax.
func (w *ESMethodWrapper) SetNoError() *ESMethodWrapper {
	w.HasNoError = true
	return w
}

func (w *ESMethodWrapper) SetCustomImplementation() *ESMethodWrapper {
	w.CustomImplementation = true
	return w
}

func (w *ESMethodWrapper) ensureMap() {
	if w.Arguments == nil {
		w.Arguments = make(map[string]*ESMethodArgument)
	}
}

func (w *ESMethodWrapper) Argument(name string) (result *ESMethodArgument) {
	w.ensureMap()
	var ok bool
	if result, ok = w.Arguments[name]; !ok {
		result = new(ESMethodArgument)
		w.Arguments[name] = result
	}
	return result
}
