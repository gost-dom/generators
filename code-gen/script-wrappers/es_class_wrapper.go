package wrappers

type TypeCustomization []string

type ESMethodArgument struct {
	required   bool
	hasDefault bool
}

func (a *ESMethodArgument) Required()   { a.required = true }
func (a *ESMethodArgument) HasDefault() { a.hasDefault = true }

// ESMethodWrapper contains information about how to generate ES wrapper code
// around a single class method.
type ESMethodWrapper struct {
	// When set, the ES wrapper will generate an error with the message, "Not implemented"
	NotImplemented bool
	// When set, nothing will be generated for the member
	Ignored bool
	// HasNoError tells that the wrapped Go method doesn't generate an error.
	HasNoError bool
	// CustomImplementation tells that the wrapper code will be generated by hand.
	// Code generator will still install a function on the prototype template
	// referencing the custom function
	CustomImplementation bool
	Arguments            map[string]*ESMethodArgument
}

// ESClassWrapper contains information about how to generate ES wrapper code
// around a class in the web specification.
//
// All classes will be generated using a set of defaults. Data in this structure
// will allow deviating from the defaults.
type ESClassWrapper struct {
	TypeName        string
	InnerTypeName   string
	WrapperTypeName string
	Receiver        string
	RunCustomCode   bool
	WrapperStruct   bool
	Customization   map[string]*ESMethodWrapper
}

func (w *ESClassWrapper) ensureMap() {
	if w.Customization == nil {
		w.Customization = make(map[string]*ESMethodWrapper)
	}
}

func (w *ESClassWrapper) MarkMembersAsNotImplemented(names ...string) {
	w.ensureMap()
	for _, name := range names {
		w.Customization[name] = &ESMethodWrapper{NotImplemented: true}
	}
}

func (w *ESClassWrapper) GetMethodCustomization(name string) (result ESMethodWrapper) {
	if val, ok := w.Customization[name]; ok {
		result = *val
	}
	return
}

func (w *ESClassWrapper) Method(name string) (result *ESMethodWrapper) {
	w.ensureMap()
	var ok bool
	if result, ok = w.Customization[name]; !ok {
		result = new(ESMethodWrapper)
		w.Customization[name] = result
	}
	return result
}

// SetNotImplemented is a simple wrapper around [NotImplemented] to support a
// chaning DSL syntax.
func (w *ESMethodWrapper) SetNotImplemented() *ESMethodWrapper {
	w.NotImplemented = true
	return w
}

func (w *ESMethodWrapper) Ignore() *ESMethodWrapper {
	w.Ignored = true
	return w
}

// SetNoError is a simple wrapper around [HasNoError] to support a
// chaning DSL syntax.
func (w *ESMethodWrapper) SetNoError() *ESMethodWrapper {
	w.HasNoError = true
	return w
}

func (w *ESMethodWrapper) SetCustomImplementation() *ESMethodWrapper {
	w.CustomImplementation = true
	return w
}

func (w *ESMethodWrapper) ensureMap() {
	if w.Arguments == nil {
		w.Arguments = make(map[string]*ESMethodArgument)
	}
}

func (w *ESMethodWrapper) Argument(name string) (result *ESMethodArgument) {
	w.ensureMap()
	var ok bool
	if result, ok = w.Arguments[name]; !ok {
		result = new(ESMethodArgument)
		w.Arguments[name] = result
	}
	return result
}
